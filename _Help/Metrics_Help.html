<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href="data:text/css;charset=utf-8,body%20%7B%0Amargin%3A%20auto%3B%0Apadding%2Dright%3A%201em%3B%0Apadding%2Dleft%3A%201em%3B%0Amax%2Dwidth%3A%2068em%3B%20%0Aborder%2Dleft%3A%201px%20solid%20black%3B%0Aborder%2Dright%3A%201px%20solid%20black%3B%0Acolor%3A%20black%3B%0Afont%2Dfamily%3A%20Verdana%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%20100%25%3B%0Aline%2Dheight%3A%20140%25%3B%0Acolor%3A%20%23333%3B%0A%7D%0Ablockquote%20%7B%0Aborder%2Dleft%3A%205px%20solid%20%23cccccc%3B%0Amargin%2Dleft%3A%2020px%3B%0Apadding%3A%200%200%200%2015px%3B%0A%7D%0Apre%20%7B%0Aborder%3A%201px%20dotted%20gray%3B%0Aborder%2Dstyle%3A%20dotted%3B%0Abackground%2Dcolor%3A%20%23f5f5f5%3B%20%0Adisplay%3A%20block%3B%0Acolor%3A%20%23f5f5f5%3B%0Apadding%2Dtop%3A%200%3B%0Apadding%2Dbottom%3A%200%3B%0A%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20monospace%3B%0Afont%2Dsize%3A%20115%25%3B%0Abackground%2Dcolor%3A%20transparent%3B%0Acolor%3A%20%231d9d1d%3B%0A%7D%0Ah1%20a%2C%20h2%20a%2C%20h3%20a%2C%20h4%20a%2C%20h5%20a%20%7B%0Atext%2Ddecoration%3A%20none%3B%0Acolor%3A%20%237a5ada%3B%0A%7D%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%20%7B%0Afont%2Dfamily%3A%20verdana%3B%0Afont%2Dweight%3A%20bold%3B%0Aborder%2Dbottom%3A%20none%3B%20%0Acolor%3A%20%237a5ada%3B%20%7D%0Ah1%20%7B%0Afont%2Dsize%3A%20130%25%3B%0A%7D%0Ah2%20%7B%0Afont%2Dsize%3A%20110%25%3B%0A%7D%0Ah3%20%7B%0Afont%2Dsize%3A%2095%25%3B%0A%7D%0Ah4%20%7B%0Afont%2Dsize%3A%2090%25%3B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Ah5%20%7B%0Afont%2Dsize%3A%2090%25%3B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Ah1%2Etitle%20%7B%0Afont%2Dsize%3A%20200%25%3B%0Afont%2Dweight%3A%20bold%3B%0Apadding%2Dtop%3A%200%2E2em%3B%0Apadding%2Dbottom%3A%200%2E2em%3B%0Atext%2Dalign%3A%20left%3B%0Aborder%3A%20none%3B%0A%7D%0Adt%20code%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Add%20p%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0A%23footer%20%7B%0Apadding%2Dtop%3A%201em%3B%0Afont%2Dsize%3A%2070%25%3B%0Acolor%3A%20gray%3B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Atable%20%7B%0Amargin%2Dbottom%3A%202em%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dspacing%3A%200%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Abackground%2Dcolor%3A%20%23eee%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0Atable%20td%20%7B%0Apadding%3A%20%2E2em%201em%3B%0Aborder%2Dtop%3A%201px%20solid%20%23ddd%3B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0Avertical%2Dalign%3A%20top%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<h1 id="metrics-capture-signs-of-trouble-during-a-run">Metrics: Capture Signs of Trouble During A Run</h1>
<h1 id="performance-metrics-box">Performance Metrics Box</h1>
<blockquote>
<p>The disk performance measures do pertain to the NI data stream, but most metrics are specific to imec devices.</p>
</blockquote>
<h2 id="errors">Errors</h2>
<pre><code>GOOD: No entries in this section.
BAD:  Any entries in this section.</code></pre>
<p>For each imec stream we monitor the cumulative count of several error flags, hence, imec05 denotes the flags for probe steam 5. Note that quad-base probes (part number NP2020) record flags for each shank, hence, quad03-2 denotes that stream 3 is a quad-probe and the flags are from shank 2.</p>
<p>The flags are labeled {COUNT, SERDES, LOCK, POP, SYNC, MISS}.</p>
<p>These flags correspond to bits of the status/SYNC word that is visible as the last channel in the graphs and in your recorded data (quad-probes have 4 separate status words):</p>
<pre><code>bit 0: Acquisition start trigger received
bit 1: not used
bit 2: COUNT error
bit 3: SERDES error
bit 4: LOCK error
bit 5: POP error
bit 6: Synchronization waveform
bit 7: SYNC error (unrelated to sync waveform)
bit 11: MISS missed sample</code></pre>
<p>To give a little insight into these flags:</p>
<ul>
<li><p>COUNT and SYNC errors (bits 2, 7): These are communication problems. You can provoke these errors by wiggling the probe flex in the headstage ZIF connector, though that isn't the only possible cause.</p></li>
<li><p>SERDES error (bit 3): This is also a communication issue and is often seen when using commutators spliced into the 5-meter cable, though that isn't the only possible cause.</p></li>
<li><p>POP error (bit 5): This is an internal buffer overflow problem caused by &quot;back pressure,&quot; meaning the data acquisition is not keeping up with the sample generation rate. Basically the computer is either running too slowly, or it is distracted by high levels of activity from other tasks running on the machine {system updates, background maintenance, browsers, starting big programs,...}.</p></li>
</ul>
<p>The MISS field counts the total number of samples that the hardware has missed due to any of the other error types. SpikeGLX inserts zeros into the stream to replace missed samples, and each of those samples has the MISS bit set in the status word.</p>
<p>The inserts are recorded in a file at the top level of your data directory. The name of the file will be &quot;runname.missed_samples.imecj.txt&quot; for probe-j or &quot;runname.missed_samples.obxj.txt&quot; for OneBox ADC stream-j. There is an entry in the file for each inserted run of zeros. The entries have the form: <sample,nzeros>, that is, the first value is the sample number at which the zeros are inserted (measured from the start of the acquisition run) and the second value is the number of inserted zeros. Each inserted sample is all zeros except for the status word(s) which set bit 11 and extend the flags from the neighbor status words.</p>
<blockquote>
<p>It is possible to see which region of recorded data experienced these errors if you see blips on those bits.</p>
</blockquote>
<hr />
<h2 id="acquisition-fifo-filling">Acquisition: FIFO Filling</h2>
<pre><code>GOOD: Lower than    4% full.
BAD:  Greater than 20% full.</code></pre>
<p>Samples acquired from each imec stream are held in a FIFO buffer on the BS card until the SpikeGLX acquisition loop fetches them into the computer for processing. If the computer is running slow the buffers will start to fill up which is NOT what you want. The only harm in running with a small amount of filling is that the latency is a little longer.</p>
<p>If the level rises to 95% full for any stream SpikeGLX will stop the run before an overflow (data loss) occurs.</p>
<hr />
<h2 id="acquisition-worker-thread-activity">Acquisition: Worker Thread Activity</h2>
<pre><code>GOOD: Lower than   75% active. // if NP1.0 or NP2.0
BAD:  Greater than 90% active. // if NP1.0 or NP2.0</code></pre>
<p>This is akin to CPU activity level you may be familiar with in the Windows Task Manager. SpikeGLX runs one or more worker threads (sub-processes). Each worker is responsible for acquiring data from between one and three probes/OneBoxes, and it marshals those data into the history streams where you can graph it, record it, and so on. The workers check for fresh data to process about 500 times per second to keep the latency low. When there isn't much to do, a worker sleeps and allows other threads more time to do their jobs. This metric shows the percentage of time that a stream, really, its worker, is awake and processing data.</p>
<p>If the system is running very comfortably the workers will easily handle their task and be able to snooze often. If the system is struggling and work is piling up the workers will have to go into overtime to catch up. If SpikeGLX can not catch up, the run may be stopped due to a FIFO overflow or other exceeded limit.</p>
<blockquote>
<p>Note: High channel count probes, like quad-base NP202X or NXT NP30XX, need more worker activity to keep up. Values greater than 75% are considered normal for these probes.</p>
</blockquote>
<blockquote>
<p>Note: If you check the <code>Low latency</code> box on the <code>IM Setup</code> tab of the <code>Configure</code> dialog, the data fetching workers run at full speed without yielding. The activity will be reported as a normal 100%.</p>
</blockquote>
<h3 id="dealing-with-stress.">Dealing with stress.</h3>
<ul>
<li><p><strong>Other Applications</strong>: Momentary stresses are caused by launching Excel, MATLAB or other resource hogging bursts of activity. Try to run as few applications as possible to prevent overtaxing the CPUs.</p></li>
<li><p><strong>Filtered IM Streams</strong>: This feature is accessed on the <code>IM Setup</code> tab. Although these streams dramatically improve signal to background for audio output and the ShankViewers, they are very compute intensive, especially for high channel count probes like the NP2020 Quad-base and NP3XXX NXT probes.</p></li>
<li><p><strong>Audio</strong>: Listening to audio channels is a huge burden on the system. It's usually fine unless you are recording to disk, which is one of the next biggest stressors. To ensure successful recording, try not to run audio when not needed.</p></li>
<li><p><strong>More Traces</strong>: This window doubles the graphing work load, try closing the secondary Graphs window to allow more resource for critical recording.</p></li>
<li><p><strong>Fewer Probes</strong>: Every PC will have an inherent limit to the number of imec probes it can handle. It takes a modern workstation with NVMe drives and 7th or 8th generation CPUs to manage 16+ probes.</p></li>
</ul>
<hr />
<h2 id="disk-write-buffer-filling">Disk: Write Buffer Filling</h2>
<pre><code>GOOD: Lower than    5% full.
BAD:  Greater than 40% full.</code></pre>
<p>When recording is in progress, each stream transfers data to be written from the history stream into a holding <code>write buffer</code>. A worker thread transfers the data from the write buffer to the disk when the disk is available. This adds a little extra tolerance against data loss should the disk be running slow.</p>
<p>There values are the worst case filling percentage for each type of stream in the run.</p>
<p>These data are also shown as <code>FileQFill%</code> in the status bar at the bottom of the Console window when recording is enabled.</p>
<hr />
<h2 id="disk-actual-and-required-write-rate">Disk: Actual (and Required) Write Rate</h2>
<pre><code>GOOD: Actual and Required match.
BAD:  Actual lower than Required.</code></pre>
<p>There are two values shown. The average write rate in MB/s for all of the streams in the run and the target write rate needed to keep up.</p>
<p>These data are also shown in the status bar at the bottom of the Console window when recording is enabled.</p>
<hr />
<h2 id="disk-fetch-depth">Disk: Fetch Depth</h2>
<pre><code>GOOD: Higher than 50%.
BAD:  Lower than  10%.</code></pre>
<p>Think of the history stream as a conveyor belt where samples from the hardware are placed on the right hand side and they travel on the belt to the left. Any client needing access to samples {audio, disk, graphing, MATLAB, ...} can pick them up off the belt anywhere, but once data items get all the way to the left end they are discarded to make room for new data entering on the right. So data on the right are fresh/new and left-hand data are oldest.</p>
<p>This metric describes where the trigger (file writing) worker is getting its samples, as a percentage of the distance along the stream (the belt) from left to right. High values mean we are pulling the latest samples, which we should be able to do unless the system is bogging down. If the workers responsible for getting data are running slow and falling behind then their target samples will have travelled some distance to the left before being picked up for recording.</p>
<p>SpikeGLX will stop the run if any recording streams are so late that their data have dropped off the left-hand side.</p>
<blockquote>
<p>Note: If the trigger client persistently reports <code>101%</code> that tells us this client is running alright but the history queue isn't getting fresh samples at an adequate pace. Either the acquisition worker thread that moves data from the hardware buffer to this history queue is running too slowly, or the flow of data into the hardware buffer may have stopped.</p>
</blockquote>
<hr />
<h1 id="errors-and-warnings-box">Errors and Warnings Box</h1>
<p>The box captures all the error and warning messages that are also being sent to the main Console window, but only within the span of the current run.</p>
<p>The box is cleared at the start of the next run.</p>
<p><em>fin</em></p>
</body>
</html>
